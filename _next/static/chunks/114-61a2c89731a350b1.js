(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[114],{5493:function(e,t,o){"use strict";o.d(t,{Z:function(){return Layout}});var a=o(5893),n=o(9008),i=o.n(n),s=o(7294);function Layout(e){let{pageTitle:t,children:o}=e;return(0,a.jsxs)(s.Fragment,{children:[(0,a.jsx)(i(),{children:(0,a.jsx)("title",{children:"".concat(t," - ").concat("Johannes Qvarford's career site")})}),o]})}},3689:function(e,t,o){"use strict";o.d(t,{j:function(){return findBySlug},x:function(){return p}});var a=o(5893),n=o(7294);function ProjectSummary(e){let{language:t,languages:o,year:n,yearEnd:i,group:s,groupType:r}=e,h=t?"Language: ".concat(t):"Languages: ".concat(o.join(", ")),l=i?"Years: ".concat(n,"-").concat(i):"Year: ".concat(n);return(0,a.jsxs)("div",{className:"project-summary",children:[(0,a.jsx)("div",{className:"project-summary-language",children:h}),(0,a.jsx)("div",{className:"project-summary-period",children:l}),(0,a.jsxs)("div",{className:"project-summary-group",children:[r||"Institution",": ",s]})]})}var i=o(1664),s=o.n(i),r=o(5302),h=o.n(r),l=o(9437),d=o.n(l),c=o(6462),u=o.n(c);function TechStackEntry(e){let{name:t,stack:o}=e;return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("h5",{children:"Backend"}),(0,a.jsxs)("dl",{children:[(0,a.jsx)(Section,{section:o.backend.implementation}),(0,a.jsx)(Section,{section:o.backend.testing})]}),(0,a.jsx)("h5",{children:"Frontend"}),(0,a.jsxs)("dl",{children:[(0,a.jsx)(Section,{section:o.frontend.implementation}),(0,a.jsx)(Section,{section:o.frontend.testing})]}),(0,a.jsx)("h5",{children:"Infrastructure"}),(0,a.jsx)("dl",{children:(0,a.jsx)(Section,{section:o.infrastructure})})]})}function Section(e){let{section:t}=e;return Object.entries(t).map(e=>{let[t,o]=e;return(0,a.jsx)(Row,{category:t,value:o},t)})}function Row(e){let{category:t,value:o}=e;return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("dt",{children:t}),(0,a.jsx)("dd",{children:o})]})}let m={static:{backend:{implementation:{Language:"None",Database:"None","Framework Libraries":"None","Database Libraries":"None","Api Libraries":"None","Other Libraries":"None","Build Tools":"None",Conformance:"None"},testing:{"Test Runner":"None","Test Coverage":"None","Tests as Documentation":"None",Mocking:"None","Integration Testing":"None"}},frontend:{implementation:{"Scripting Language":"Javascript","Styling Language":"SCSS","Markup Language":"HTML","Framework Libraries":"Jekyll","Api Libraries":"None","State Management Libraries":"None","Other Libraries":"None","Build Tools":"Jekyll","Scripting Conformance":"None","Styling Conformance":"None"},testing:{"Test Runner":"None","Test Coverage":"None","Tests as Documentation":"None",Mocking:"None","Integration Testing":"None"}},infrastructure:{"End2End Testing":"None","Version Control System":"Git","Version Control Platform":"Github","Continuous Integration Platform":"Github","Documentation Platform":"Github Pages","Deployment Platform":"Github Pages"}},dynamic:{backend:{implementation:{Language:"Javascript",Database:"Postgres","Framework Libraries":"Express","Database Libraries":"node-postgres, node-pg-migrate","Api Libraries":"OpenApi Generator","Other Libraries":"None","Build Tools":"yarn",Conformance:"eslint(AirBnB)"},testing:{"Test Runner":"jest","Test Coverage":"jest","Tests as Documentation":"None",Mocking:"jest","Integration Testing":"supertest"}},frontend:{implementation:{"Scripting Language":"Javascript","Styling Language":"CSS","Markup Language":"JSX","Framework Libraries":"React","Api Libraries":"Fetch","State Management Libraries":"Redux Toolkit","Other Libraries":"lodash, date-fns","Build Tools":"yarn, gatsby.js","Scripting Conformance":"eslint(AirBnB)","Styling Conformance":"stylelint(stylelint-config-standard, stylelint-config-rational-order)"},testing:{"Test Runner":"jest","Test Coverage":"jest","Tests as Documentation":"None",Mocking:"jest","Integration Testing":"msw, 'testing-library/react'"}},infrastructure:{"End2End Testing":"Cypress","Version Control System":"Git","Version Control Platform":"Github","Continuous Integration Platform":"Github Actions","Documentation Platform":"Github Pages","Deployment Platform":"Azure (ARM Template)"}},microService:{backend:{implementation:{Language:"Kotlin",Database:"Postgres","Framework Libraries":"Quarkus","Database Libraries":"JooQ, Liquibase","Api Libraries":"OpenApi Generator (JAX-RS server stub, MicroProfile+Rest-easy client)","Other Libraries":"MapStruct, Immutables","Build Tools":"Gradle",Conformance:"Klint+detekt"},testing:{"Test Runner":"JUnit5","Test Coverage":"Jacoco","Tests as Documentation":"OpenApi spec+Pact",Mocking:"Mockito","Integration Testing":"Rest-Assured+TestContainers+Pact"}},frontend:{implementation:{"Scripting Language":"Typescript","Styling Language":"CSS","Markup Language":"JSX","Framework Libraries":"React","Api Libraries":"Fetch","State Management Libraries":"Redux Toolkit","Other Libraries":"lodash, date-fns","Build Tools":"yarn, gatsby.js","Scripting Conformance":"eslint(AirBnB)","Styling Conformance":"stylelint(stylelint-config-standard, stylelint-config-rational-order)"},testing:{"Test Runner":"jest","Test Coverage":"jest","Tests as Documentation":"None",Mocking:"jest","Integration Testing":"msw, 'testing-library/react'"}},infrastructure:{"End2End Testing":"Selenide","Version Control System":"Git","Version Control Platform":"Github","Continuous Integration Platform":"Github Actions","Documentation Platform":"Github Pages","Deployment Platform":"Azure (ARM Template)"}}};function findBySlug(e){return p.filter(t=>t.metadata.slug==e)[0]}let p=[{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("h3",{children:"Abstract"}),(0,a.jsx)("p",{children:'Chess is a game that is often used to examine different techniques in AI. In this thesis, the following question is asked: "Is it possible to develop an AI-agent whose decision making is based on the technique Case-based Reasoning (CBR) that uses shallow similarity, and plays better using case bases based on the better players?". An AI-agent has been developed that has played a number of games against itself using different case bases based on different players. After examining the results, it turned out that the AI-agent plays so bad that it almost never manages to win regardless of case base, which meant that it was not possible to grade them based on skill. It\'s could still be useful to examine if a CBR-based chess playing AI-agent could play chess with great skill.'}),(0,a.jsxs)("p",{children:["The whole ",(0,a.jsx)("a",{href:"http://urn.kb.se/resolve?urn=urn:nbn:se:his:diva-11049",children:"thesis report"})," is available for download."]}),(0,a.jsx)(ProjectSummary,{language:"C#",year:2015,group:"HiS"}),(0,a.jsx)("h3",{children:"Programming Experience"}),(0,a.jsx)("p",{children:"This project was very interesting to work with because it gave me a chance to program in a more functional style than I've previously been used to. Immutable Classes were written, and their public interfaces were severely restricted to the bare minimum, which made it harder to write bug ridden code. Almost everything chess related was unit tested, and I never even ran the program before all the tests passed."}),(0,a.jsx)("p",{children:"While this may have been working great in the beginning, I was soon faced with a performance problem, mostly related to unnecessary and expensive allocations of lists and boards. In order to fix the problem, I changed the representation and implementation of some classes without changing their public interfaces. This allowed me to test any changes I made, to make sure that I didn't introduce a bug."}),(0,a.jsx)("p",{children:"So, in the end I introduced mutability in order to solve the problem. However, that doesn't mean that it was a waste of time to program functionally at the start."}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"The immutability caused the class interfaces to shrink, which sped up the initial testing process."}),(0,a.jsx)("li",{children:"Even if the initial implementation and representations where replaced, they were quick to develop, and led to clearer code."}),(0,a.jsx)("li",{children:"Due to the non-existence of mutable state-sharing, it was easy to scale the program to simulate multiple chess games in parallel using PLINQ."})]}),(0,a.jsx)("p",{children:"This experience has lead me to develop in a more functional style, and writing more unit tests. Unfortunately, sometimes the pros aren't worth it on short projects with rapidly changing requirements. It's important to be pragmatic, and use the right tool for the right job."})]})},metadata:{title:"A Case-Based Reasoning Approach to A Chess AI Using Shallow Similarity",slug:"case-based-reasoning",date:"2015-11-02"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("div",{className:h().titleImages,children:(0,a.jsx)("img",{src:"/assets/winter-dreams.jpg",title:"Title screen of the game - Winter Dreams",alt:"A natively dressed women stares into the distance. The dark landscape is covered in snow and ice.  "})}),(0,a.jsx)("h3",{children:"Project Summary"}),(0,a.jsx)(ProjectSummary,{language:"C++",year:"2013",group:"HiS"}),(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsx)("p",{children:"Winter Dreams is a game about a winter princess that gets trapped in her dreams, and has to escape by solving puzzles. The game uses an isomorphic camera, and includes features such as voiced dialogue with subtitles, cutscenes, shader lighting, dynamic footprints and Ukontr\xf8ll support. It supports dynamic loading of levels, settings and entity type properties without recompilation."}),(0,a.jsxs)("p",{children:["A demo of the game was released in April 2013, and the source code for the demo can be found ",(0,a.jsx)(s(),{href:"https://github.com/johannes-qvarford/Winter-Dreams",children:"here"}),". A trailer for the demo was also released ",(0,a.jsx)(s(),{href:"https://www.youtube.com/watch?v=A5969PjI02I&feature=youtu.be",children:"here"}),"."]}),(0,a.jsx)("p",{children:"This was my first big collaborative project at the University of Sk\xf6vde, and also my first major role as a lead programmer. It was my responsibility to organize the other programmers, communicate between us and the other leads, as well as programming a large part of the game."}),(0,a.jsx)("h3",{children:"As a Programmer"}),(0,a.jsx)("p",{children:"I was in charge of the level loading system, which was eventually expanded for loading settings and entity type properties. We used Tiled to design levels, because it was the first best editor we could find that supported isomorphic 2D levels. Tiled levels could be exported to JSON, so my first task was to use a library to parse the JSON, create the entities and tiles, and finally run the game."}),(0,a.jsx)("p",{children:"The game had many different entity types, so in order to handle the complexity of parsing the levels, I created the so called Entity Registration System (ERS). The ERS tied every entity type to a name, and a function for converting a serialized entity to an in-memory entity. When a serialized entity was found, its name was used to lookup the correct conversion function and create the entity. So called Entity Registrations were used to register the entity type at startup. By declaring a global Entity Registration with a name and a function, the entity type was registered as soon as the game started. It's debateable if using global variables like this was a good idea; it sped up compilation time, as there was no need for a big registration function that grew every time a new entity type was added, but at the same time it made the control flow less intuitive."}),(0,a.jsx)("p",{children:"Compilation took a very long time on our school computers, and changing a single entity property's default value could result in a triple digit compilation time in seconds. To speed up development, entity property default values and general settings were moved out of the source files, and into configuration files that were loaded when the game started. We still had to reload the game, which started to take longer and longer towards the end of the project, so it might've been fitting to continuously check for changes in the configuration files, and reload them as necessary during runtime."}),(0,a.jsx)("p",{children:"In order to make it easier for designers to control gameplay flow, I implemented the Trigger Activation System (TAV). The TAV tied every entity to a state, active or not and allowed them to be react to state changes. Different entities got triggered in different ways and behaved differently when they were activate or not, which was implemented by us programmers. However, how the entities reacted when they got triggered could be decided by the designers. For instance, we could program a trigger area that got triggered when its area collided with the player, and we could also program an entity whose only goal is play some dialogue when it was activated. The designers could then create different areas that activated different pieces of dialogue when each area got triggered."}),(0,a.jsx)("p",{children:"I handled some smaller tasks as well, like implementing lights. The levels were dark, but contained several light sources scattered across the level, and one surrounding the player. The radius and brightness of the light surround the player increased as the player healed themselves and decreased as they took damage. The effect was implemented by using a pixelation shader, and darkening pixels based on their distances to the light sources."}),(0,a.jsx)("h3",{children:"As a Lead"}),(0,a.jsx)("p",{children:"I had been programming in high school, so at this point I had much more programming experience than the others. As such, I felt that I had to teach the team how best to structure the code, documentation and handle version control. It was tough to be doing everything at once, but I felt that I was best suited for all of the responsibilities. Maybe in a bigger project I would feel the need to delegate the responsibility to avoid getting stressed out, but for this project it worked fine. I was also lucky to have a talented programmer by my side who helped me brainstorm ideas and implement some of the more more advanced parts of the game."}),(0,a.jsx)("p",{children:"I failed as a leader when it came to dealing with one of the other programmers. The other programmer had concentration issues and would disregard agreed upon task assignments and coding standards, which among other things caused me and the rest of the programmers to grow hostile towards him. I didn't want to deal with him, so I gave him a big task hoping that it would keep him preoccupied and out of my hair for a long time. However, due to my lack of leadership, I didn't push him hard enough to perform the task, and it was delayed several weeks. I shouldn't have let my personal issues with the programmer risk the completion of the project."}),(0,a.jsx)("p",{children:"Another programmer who was difficult for me to deal with had a different problem. He wasn't very good or enthusiastic about programming and even stated outright that he would be switching his major the next semester. I tried to give him some simple tasks to perform but it usually resulted in me showing him how to do most of the work. I don't blame him for not wanting to program, but it put me in a difficult spot in deciding how he could contribute to the project. I could've given him even simpler tasks to perform, but these would have to be artificially created, not out of need for the project and still take time to think of. This would've at least have given him something to show to the teachers so he wouldn't have failed the course. I could've also shown him how to do his assigned tasks, but this would've kept me occupied while I had my own things to do. I could also have given him no tasks to perform, but this would've certainly made him fail the course, and I didn't want him to feel useless."}),(0,a.jsx)("p",{children:"In the end, I gave him tasks, and showed him how to do those that he thought were too hard. I still don't know the best way to handle the situation, to slow down the project or risk hurting his feelings. I should've maybe talked with him and the teachers to get more input for what they felt was best, and based my decision on that. It's also very different to make this decision in a school project, as opposed to a corporate one. In a corporate project he would probably have been let go for not contributing enough, but the point of the school project was not to 100% simulate a corporate project."}),(0,a.jsx)("h3",{children:"Summary"}),(0,a.jsx)("p",{children:"While it wasn't always easy, we managed to crank out a good demo with interesting features. I learned a lot about how to effectively work in a group and how to use a lot of programming libraries. I liked being a programming lead a lot, and I really enjoyed planning the project and overseeing the programmers' work, making sure they finished their tasks on time. Still, I sometimes struggled as a leader, and this project taught me more than anything, not to do half-measures. I shouldn't have given tasks to the unmotivated programmer for the sake of giving tasks, I should have consulted with the teachers, to at best be given a solution, and at worst be given input. I also shouldn't have given the troubling programmer a task and then not checked up on how he was doing. I carried these lessons with me, to my next project: Lunch Lady Simulator."})]})},metadata:{title:"Winter Dreams",slug:"winter-dreams",date:"2016-01-10"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("div",{className:h().titleImages,children:(0,a.jsx)("img",{src:"/assets/lunch-lady-simulator-512px.jpg",alt:"An angry lunch lady strikes an action pose. Tomato sauce and fire swirl in the background.",title:"Lunch Lady Simulator promotional image"})}),(0,a.jsx)("h3",{children:"Project Summary"}),(0,a.jsx)(ProjectSummary,{language:"C#",year:2014,group:"HiS"}),(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsx)("p",{children:"Lunch Lady Simulator is a comical physics based simulator about being a lunch lady. The goal of the game is to serve as many customers as possible while struggling with wonky yet entertaining controls. It draws heavy inspiration from Surgeon Simulator."}),(0,a.jsx)("p",{children:"The game features various physics based food items and tools, FMOD integrated music, voice acting and automatically generated customers."}),(0,a.jsxs)("p",{children:["A demo of the game was finished in June 2014, and the source code can be found on the ",(0,a.jsx)(s(),{href:"https://github.com/johannes-qvarford/LunchLadySimulator",children:"Lunch Lady Simulator Github repository"}),". Lunch Lady Simulator is part of the ",(0,a.jsx)(s(),{href:"http://democreativity.com/games",children:"Democreativity project game showcase"}),", encouraging creative game development. The project was developed during the ",(0,a.jsx)(s(),{href:"http://www.his.se/om-oss/Utbildningar-och-amnen/Data-och-IT/Microsoft-Game-Camp-2014/",children:"Microsoft Game Camp 2014 event"}),"\xa0which was a great opportunity for game developers to program towards various Microsoft devices. There's a ",(0,a.jsx)(s(),{href:"https://www.youtube.com/watch?v=TV94WJM8CO0",children:"Lunch Lady Simulator playthrough"})," available of the demo, by the youtuber DualDGaming."]}),(0,a.jsx)("p",{children:"This project was a bit of a struggle, and I had to share the role of lead programmer throughout the project. As a lead, I had to organize the other programmers and communicate with the other leads. I was also the person responsible for handling input, arm physics and soup physics."}),(0,a.jsx)("h3",{children:"As a programmer"}),(0,a.jsx)("p",{children:"I was assigned to develop the main physical parts of the game. We were using Unity, which took care of a lot of the work, and allowed me to try out different strategies from a higher abstraction level. While it may normally have been good to let a designer string together a few physical components, the high demands of the design meant that the arms had to be hand coded."}),(0,a.jsx)("p",{children:"For example: The arms are so heavy that they, and any tools they are holding, should never be pushed by anything. At the same time, the arms shouldn't push the food items too far away when they touch, meaning that the arms both had a great mass (don't get pushed by anything) and a lighter mass (don't exert too much force) at the same time."}),(0,a.jsx)("p",{children:"Lunch Lady Simulator had a lot of different control schemes during development that needed to be tested and integrated into the game. There was a control scheme for keyboard, one for single player controller, one for co-op controller and one for Kinect. While another programmer handled Kinect programming, It was hard to manage all these different control schemes due to limitations in Unity. When checking if e.g. the player is moving their arm forward, you had to dynamically construct a string that specified the control scheme, and then check the key was down (on the keyboard) or the trigger was pressed down enough (on the controller). Given how well known and common this issue with Unity is, there was probably an asset available on the Asset Store that could've helped us, but we ran on a 0 SEK budget without salary, and it wouldn't be fair to the other teams to gain such an advantage through monetary means."}),(0,a.jsx)("h3",{children:"As a lead"}),(0,a.jsx)("p",{children:"In the beginning of the project, I had high hopes. I was able to assign big tasks to the other programmers, and it looked like everyone would be occupied for a while. I was unfortunately wrong about that, and quickly discovered that the programmer who was supposed to do water physics, was unable too, partly because of limitations in Unity and performance constraints. Meanwhile, I was too occupied with the physics implementation to manage the team and while we all developed out parts of the game, we had not merged our work by week 4. That's when another programmer stepped in to take charge of the programmers, and he took over as a lead for the time being."}),(0,a.jsx)("p",{children:"Later in the project, he was often away implementing the Kinect support (the dev kits were in a different building) so I had to take over for him. By the end of the project, I was fully back in action as the lead programmer, even though it wasn't explicitly stated before the end of the project."}),(0,a.jsx)("p",{children:"To be honest, I was really stressed out during the project. I had just joined Deedly Games, and was working there on my spare time. Since I worked on the project for 40 hours a week and worked at Deedly Games for 20 hours a week, I did not have a single free day to relax. I probably shouldn't have handled the physics as well as taking on a lead role, as the physics consumed too much of my time, which should've gone to managing the other programmers. I just felt at the time that the physics was the hardest and most time consuming task, and that we wouldn't have finished on time with a good result, if one of the other programmers handled it. I probably shouldn't have put soo much weight on my shoulders and just accepted that I couldn't put the well-being of the project over my own."}),(0,a.jsx)("h3",{children:"Summary"}),(0,a.jsx)("p",{children:"Despite bumps on the road, the project was finished on time and drew a big audience which really enjoyed it, particularly the co-op mode. I learned a lot about the features and limitations of Unity, as well as many game physics concepts and applications. Throughout the project I realized that I couldn't do everything and please everyone, and that I had to put myself before the project. Nowadays, I never do heavy crunches during longer periods of time, because I know that they can have a devastating effect."})]})},metadata:{title:"Lunch Lady Simulator",slug:"lunch-lady-simulator",date:"2016-01-22"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("div",{className:h().titleImages,children:(0,a.jsx)("img",{src:"/assets/tiny-tricky-tiles-512px.jpg",alt:"4 differently colored blocks with cartoonish expressions stand next to the game's title.",title:"Promotional image for the game Tiny Tricky Tiles"})}),(0,a.jsx)("h3",{children:"Project Summary"}),(0,a.jsx)(ProjectSummary,{language:"C#",year:2014,yearEnd:2015,group:"Solutions Sk\xf6vde",groupType:"Company"}),(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsxs)("p",{children:["Tiny Tricky Tiles is a unique puzzle game that relies on the player's pattern recognition skills. It was developed by Solutions Sk\xf6vde, which was known as Deedly Games at the time. The team consisted of me as a programmer, ",(0,a.jsx)(s(),{href:"https://www.linkedin.com/profile/view?id=AC4AAAaTp8YBq1dBsESX9rpswYfeew0y2NJSDLs&authType=name&authToken=C7dL&trk=contacts-contacts-list-contact_name-0",children:"Helena Granstr\xf6m"})," as a graphical artist and ",(0,a.jsx)(s(),{href:"https://www.linkedin.com/in/alexander-karlsson-238913125",children:"Alexander Karlsson"})," as a programmer/designer. We developed the game on our spare time using Unity while studying at the University of Sk\xf6vde (HiS) over the course of a year."]}),(0,a.jsxs)("p",{children:[(0,a.jsx)(s(),{href:"https://play.google.com/store/apps/details?id=com.DeedlyGames.TinyTrickyTiles",children:"Download the game from Google Play"})," or ",(0,a.jsx)(s(),{href:"https://itunes.apple.com/se/app/tiny-tricky-tiles/id966125107?mt=8",children:"download the game from the App Store"}),"."]}),(0,a.jsx)("h3",{children:"Rules"}),(0,a.jsx)("p",{children:'Each puzzle consist of a rectangular game board with a group of tiles in widely different colors. The player is given a spare tile, which they can "push" into the board through a chosen row or column. The tile that gets pushed out of the board becomes the new spare tile. The player wins when all the tiles on the board are directly or indirectly connected to every other tile of the same color.'}),(0,a.jsx)("h3",{children:"Programming Challenges"}),(0,a.jsx)("p",{children:"I joined Solutions Sk\xf6vde right around the time when the team was finishing another game, by the name of Trashmania."}),(0,a.jsxs)("p",{children:["What I noticed when I looked over the code was that there was no clear ",(0,a.jsx)(s(),{href:"https://en.wikipedia.org/wiki/Separation_of_concerns",children:"Separation of Concerns"})," between the game components. There was a big god object that handled some aspects of the game, but there were also a lot of smaller components. Not only did the god object directly manipulate the smaller components' state, but the smaller components ALSO manipulated the god object's state. It was not clear where to put new functionality and it was hard to understand the execution flow."]}),(0,a.jsx)("p",{children:"Another problem was that nothing in the game was unit tested, which meant that new features almost always introduced a lot of bugs."}),(0,a.jsxs)("p",{children:["When we started working on Tiny Tricky Tiles, I wanted to avoid the mistakes performed in the development of Trashmania. I had read a lot about the ",(0,a.jsx)(s(),{href:"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller",children:"Model-View-Controller architecture"})," and how it could be used for Separation of Concerns (SoC), and about how ",(0,a.jsx)(s(),{href:"https://en.wikipedia.org/wiki/Inversion_of_control",children:"Inversion of Control"})," could be used to easily test components. StrangeIoC was an IoC container with support for MVC in Unity, which meant we could kill two birds with one stone."]}),(0,a.jsx)("p",{children:"StrangeIoC's IoC support was completely decoupled from Unity which should make it easier to test components. Game logic was performed using Commands, which resembled Controllers in MVC. Commands could be chained in sequence and run in parallel, and a failing command interrupted the entire chain. Commands were fired as a response from raised signals by views, which were activated by View components attached to Unity Game Objects. Commands propagated changes through mutations on shared injected components and through raised signals."}),(0,a.jsx)("h3",{children:"Result"}),(0,a.jsx)("p",{children:"I though that StrangeIoC was of great help at the beginning of the project - just being able to separate logical game state to the models and view state to the View components made the code much easier to comprehend for me. Not all game state was separated out of the View components though, and Unity-related code was placed in Commands which made it impossible to test them. Not that it would have mattered, because we didn't perform any testing at all. One reason for not testing was that a lot of the game logic was concerned with manipulating Game Objects, and it was too time consuming to mock a lot of the Unity functionality. Another reason was that writing tests would take lots of time, and since the spec changed frequently a lot of test code would've been outdated in no time."}),(0,a.jsx)("p",{children:"Separating responsibilities into models, views and commands may have separated concerns more, but it also bloated the project with many files, made dependencies harder to track and control flow harder to understand."}),(0,a.jsx)("p",{children:'Usually in Unity when you needed to create a game component, let\'s say "Bat", you would only need to create a "BatBehavior" class inheriting from MonoBehavior and attach it to a Bat game object. With StrangeIoC, you would create a BatView that handled collisions, updates and other unity callbacks and changes through a BatMediator which changed the BatView when receiving certain signals, and raised signals when the BatView encountered something. One or more bat-related commands may have to be created to react to the bat\'s actions, and these may need to be connected to some bat-related signals.'}),(0,a.jsx)("p",{children:"At least twice the amount of files were needed to be created to implement a traditional Unity component, and it was difficult to understand the control flow because they were loosely coupled and only used signals to communicate."}),(0,a.jsx)("p",{children:"I hoped that StrangeIoC would solve a lot of our problems, but I had my head in the clouds during the project just hoping it would work. I didn't even consider how Alexander felt about it; he didn't understand what roles the different kinds of components played and thought that the framework was needlessly complicated."}),(0,a.jsx)("h3",{children:"Conclusion"}),(0,a.jsxs)("p",{children:["The theories behind MVC and unit testing are all very useful on their own, but didn't prove to be of much use for use when developing Tiny Tricky Tiles. The StrangeIoC framework was to heavy weight and gave the code too low of a signal-to-noise ratio. Removing game logic from Unity MonoBehaviors can still be useful, and I believe we can benefit from a ",(0,a.jsx)(s(),{href:"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel",children:"Model-View-ViewModel"})," separation, where some MonoBehaviors just contains view state, some contain view related logic, while models contains view independent state and logic. It wouldn't aid with IoC and testing, but I don't believe we will perform much unit testing on games in the future."]})]})},metadata:{title:"Tiny Tricky Tiles",slug:"tiny-tricky-tiles",date:"2016-06-21"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsxs)("div",{className:d().titleImages,children:[(0,a.jsx)("img",{src:"/assets/kaizo-returns.png",title:"In-game screenshot of the rom hack - Kaizo Returns",alt:"Mario is on an airship armada. Bullet bills fire on a stormy night."}),(0,a.jsx)("img",{src:"/assets/waluigis-treasure-hunt.png",title:"Title screen of the Super Mario World rom hack - Waluigi's Treasure Hunt",alt:"Gem stones surround the title. Mountains are seen in the distance on a starlit night."})]}),(0,a.jsx)("p",{children:"Ever since I was a child, I've wanted to program computer applications. When one of my video games stopped working, I swore that when I grew up, I would contribute to making good software."}),(0,a.jsx)("p",{children:"I first started writing code in junior high. Back then, I was making ROM hacks of Super Mario World. I quickly realized that the level editor was very limiting, so I started learning assembly for the SNES to program new enemies. I released demo versions for two rom hacks: Super Mario World: Kaizo Returns and Waluigi's Treasure Hunt."}),(0,a.jsxs)("p",{children:["Feel free to download the ",(0,a.jsx)(s(),{href:"/assets/waluigis-treasure-hunt.ips",children:"patch for Waluigi's Treasure Hunt"}),". In order to play through it, you need a legal copy of a Super Mario World ROM and an SNES emulator like ZSNES."]}),(0,a.jsxs)("p",{children:["There is a ",(0,a.jsx)(s(),{href:"https://www.youtube.com/playlist?list=PL18DB9F871D181135",children:"playthrough of New Super Mario World: Kaizo Returns"})," by AuthenticZac available online."]}),(0,a.jsxs)("p",{children:["You can also watch a ",(0,a.jsx)(s(),{href:"https://www.youtube.com/watch?v=pyrkWtAfaJ0",children:"test run of Waluigi's Treasure Hunt"})," by FPZero."]})]})},metadata:{title:"Super Mario World Hacking",slug:"smw-hacking",date:"2017-11-23"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("div",{className:u().titleImages,children:(0,a.jsx)("img",{src:"/assets/bricknode.png",title:"Bricknode logo",alt:"Three v-shaped blocks of different colors loosely fitting together."})}),(0,a.jsx)(ProjectSummary,{languages:["C#","Typescript","T-SQL"],year:2016,yearEnd:2017,group:"Solutions Sk\xf6vde",groupType:"Company"}),(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsx)("p",{children:"In the fall of 2016 we were approached by Bricknode to help them build a financial module for a customer of theirs. Three developers from Solutions Sk\xf6vde including me were tasked with building the frontend and backend of the module. The module was partly an enhancement to Bricknode Financial System (BFS), and a frontend for office workers to manage financial assets, including a custom access control system."}),(0,a.jsx)("h3",{children:"In the beginning"}),(0,a.jsx)("p",{children:"Before the project officially began, I wrote a blueprint for what technologies we would use and how code would be organized. I did this to make sure that we didn't do things in widely different ways. Some choices turned out to be good, while others weren't. It especially made things hard for one of the developers when it came to code organization because of some over-abstractions. Since only one of the programmers wrote the frontend and the other wrote the backend, I definitely could've revised it earlier. Towards the end, both of the programmers had come up with their own conventions that still adhered to most of the blueprint. I was very excited to use som very new technology, but because of that we ran into problems that were hard to find solutions to on the internet."}),(0,a.jsx)("h3",{children:"As a lead"}),(0,a.jsx)("p",{children:"During the project, I was tasked with managing the other programmers as a lead: delegating work, reviewing code and writing documentation. I also communicated directly with our contact person at Bricknode so that I understood what had to be implemented. It worked pretty smoothly, but what we found out during the course of the project was that my role as mediator was necessary at the time. However, it would've been preferable if all developers could've worked on both the frontend and the backend and spoke directly to our contact person. We also noticed that work on the backend was completed much faster than the frontend, so I sometimes had to jump in to fill in the gap."}),(0,a.jsx)("h3",{children:"As a programmer"}),(0,a.jsx)("p",{children:"I developed a few things myself during the project. After 4 months our initial contract ended, and only I continued working on the project on our side because they couldn't afford all of us. I implemented a few basic resource management pages, including one for managing a shareholder's orders. I also designed a small system for abstracting CRUD controller classes on the backend to reduce boilerplate and simplify testing. We used aspnet core on the backend and Angular on the frontend. I only had a little bit of experience with Angular beforehand, so this project really made me understand how to use it."}),(0,a.jsx)("h3",{children:"Conclusion"}),(0,a.jsx)("p",{children:"The project continued after we stopped working on it, and I got the impression that they were satisfied with our work. Aside from some blunders in the original blueprint, I still think I did a good job. They must've felt so too, since they wanted me to continue working. This wasn't the first time I was a lead, but it put into perspective on how important it can be to organize the workload so that no one is left twiddling their thumbs. It also taught me to be more flexible when it came to programming conventions, so that people don't feel as forced to follow rules they don't agree with. I learned a lot about Angular, and by using a bleeding edge version of dotnet core, it made me more aware of how important it is to use tested technologies."})]})},metadata:{title:"Bricknode Financial Module",slug:"bricknode-financial-module",date:"2017-11-25"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("div",{className:h().titleImages,children:(0,a.jsx)("img",{src:"/assets/solutions-skovde.png",title:"Solutions Sk\xf6vde logo",alt:"two braces within a circle forming an s within their empty space."})}),(0,a.jsx)(ProjectSummary,{languages:["C#","Powershell","Javascript"],year:2017,group:"Solutions Sk\xf6vde",groupType:"Company"}),(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsx)("p",{children:"Solutions System is a framework I developed for quickly creating new apps for one of our clients. It uses a loosely coupled plugin system to allow for app uniformity and flexibility while preventing package bloat. It's written in C# and distributed as nuget packages. The tools for creating new apps are written in Javascript and Powershell, and Chocolatey is used for tool installation."}),(0,a.jsx)("h3",{children:"Purpose"}),(0,a.jsx)("p",{children:"We developed a lot of small apps for our client over time, but at one point we realized that it was infeasible to continue as usual. The problems were numerous:"}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:(0,a.jsx)("p",{children:"Every app looked different. Since there was no one established way to implement certain features, they were implemented differently. This made it hard to maintain them, as a developer had to be familiar with a particular app to effectively debug and extend it."})}),(0,a.jsx)("li",{children:(0,a.jsx)("p",{children:"Improvements didn't propagate to previously developed  apps. Since each app was different from the other, it was hard and time consuming to propagate improvements and bug fixes back to older apps. Because of this, not a lot of them were propagated at all, increasing the feature gap and overall difference between different apps."})}),(0,a.jsx)("li",{children:(0,a.jsx)("p",{children:"Creating new apps were time consuming and error prone. Every app included a lot of boilerplate, and the only way to speed up the app creation process was to copy paste projects and perform solution wide renames, which didn't always work correctly. Creating a project in our version control repository wasn't a problem, but adding IIS sites and apps sometimes went wrong, leading to hours of debugging."})})]}),(0,a.jsx)("p",{children:"This might have been fine if we developed relatively few projects that didn't need continuous maintenance, but for our purposes it was a disaster."}),(0,a.jsx)("h3",{children:"Early stages"}),(0,a.jsx)("p",{children:"We initially tried to solve the problem with half-baked solutions. The initial nuget packages were built as we went along, didn't follow strong enough conventions, and all packages ultimately depended on each other while still giving little room for flexibility of the http request pipeline. It was decided that I should make a dedicated effort to build a system that would stand the test of time."}),(0,a.jsx)("h3",{children:"The system"}),(0,a.jsx)("p",{children:"The solution that I devised was the Solutions System (SS), a web development framework layered upon aspnet core. The system uses plugins to specify functionality, such as which classes to register for dependency injection, and what steps to inject into the http request pipeline and where. Plugins can depend on other plugins, and are resolved recursively."}),(0,a.jsx)("p",{children:"Plugins can also have options, and a plugin's options can be combined or overwritten by the app or other plugins. The database plugin e.g. can take a list of Entity Framework DbContext types, load their connection strings, register them for dependency injection and migrate them. A plugin for a certain database would just indicate that it wanted to add its own DbContext to the database plugin's options."}),(0,a.jsx)("p",{children:"A main plugin was written that bundled things like authorization, email, logging and options that most apps needed. If the main plugin didn't suit a certain app, the app could use extra plugins, or an alternative bundle plugin could've been developed that met its needs better."}),(0,a.jsx)("h3",{children:"Libraries"}),(0,a.jsx)("p",{children:"Libraries were organized based on dependencies, purpose and feature. You had extension (Ext) libraries that simple extended a few types from a library, and then you had service (Serv) libraries that included interfaces and classes that could be dependency injected. Database (Db) libraries included Entity Framework classes to create database apis and plugin (Plug) libraries used Serv and Db libraries to create plugins."}),(0,a.jsx)("p",{children:"There were a lot of different libraries to keep track off, so to stop apps from having long confusing lists of dependencies, that complexity was moved to a msbuild props file that all projects referenced. They just indicated what they wanted to use, like Bricknode Foundation System (BFS) integration or Ratsit integration, and the props file figured out what packages were needed. It was still a manual process to copy paste the props file whenever it was updated, but it was better than the alternative of having to look through every app's csproj file."}),(0,a.jsx)("h3",{children:"Tools"}),(0,a.jsx)("p",{children:"Since many new developers were working for our client, we needed to be able to setup their development environment quickly and allow them to create new apps easily. I developed tools to solve this problem."}),(0,a.jsx)("p",{children:"The tools were written in Powershell because they used some Windows specific functionality, and Javascript because there was a good project generator package available on npm, but not on nuget. All a user had to do to create an app was to give a basic name to the project, give a title and subtitle, indicate what IIS site/app to create, and what url the project should be reachable from. Once the project was created, they could add and remove plugins however they felt like and be ready to publish instantly."}),(0,a.jsx)("h3",{children:"Downsides"}),(0,a.jsx)("p",{children:"The system worked better than expected, but there were still some minor problems with it."}),(0,a.jsx)("p",{children:"The system makes it easier to create common apps with smaller amounts of code, but there is a lot to learn on top of having to learn aspnet core. Setting up the development environment sometimes causes problems too."}),(0,a.jsxs)("p",{children:["The props file is not propagated automatically which could've been solved by downloading it and replacing the old file on checkout and commit. Alternatively, the file could be uploaded as a nuget package and referred to through an Import element with an SDK attribute. Read more about it in ",(0,a.jsx)(s(),{href:"https://github.com/Microsoft/msbuild/issues/1493",children:"MSBuild 15 Sdk Design"}),". Using both Powershell and Javascript was unfortunate, but there was no immediate solutions available for dotnet project generation."]}),(0,a.jsx)("p",{children:"On second though, most things could've been solved with a web app that creates the version control project, IIS apps and sites, and lets the developer download a zip file containing the newly created project. The web app cannot setup the developer's development environment, but it can generate a scaled down Powershell script that does."}),(0,a.jsx)("p",{children:"Certain common patterns started to emerge in apps to do simple things, and that should probably have been abstracted, even if it would've introduced redundancies in the system."})]})},metadata:{title:"Solutions System",slug:"solutions-system",date:"2017-11-25"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsx)("p",{children:"Historically, I haven't considered the idea of deciding on a tech stack. This is mostly due to the fact that I've worked in a lot of different environments that I didn't get the time to settle in with."}),(0,a.jsx)("p",{children:"Nowadays, I have a better idea on how I want to work. I've come to love XP, and I want to be able to deliver value quickly, to appreciating customers, without compromising on internal software quality."}),(0,a.jsx)("p",{children:"The article will cover the attributes that I value in my tech stacks, and a list of stacks that I prefer for different kinds of products. I'm a web developer, first and foremost, so I will not talk about stacks for embedded real-time systems or desktop applications e.g."}),(0,a.jsx)("h3",{children:"What makes a good tech stack?"}),(0,a.jsx)("h4",{children:"Metrics"}),(0,a.jsxs)("p",{children:["I will go through the 4 key metrics from the ",(0,a.jsx)(s(),{href:"https://itrevolution.com/book/accelerate/",children:"Accelerate book"})," and bring up tech stack attributes that that I believe can improve them."]}),(0,a.jsx)("h5",{children:"Deployment Frequency"}),(0,a.jsx)("p",{children:"There is little point in being able deploy frequently if the tech stack makes it hard or impossible to do. Deployment has to be automated to achieve this."}),(0,a.jsx)("p",{children:"You should be able to structure the code so that it's easy to change business logic without changing the infrastructure. And you should be able to satisfy the stakeholder that requested the change without having to change at lot of code that might affect other stakeholders. You should be able to structure code with low coupling and high cohesion, so that the area to change is easy to change and easy find."}),(0,a.jsx)("p",{children:"This means that frameworks that enforce a certain file structure and causes unnecessary coupling between business logic and infrastructure are undesirable. Some frameworks provide conventions that can be overridden. This means that long-lasting projects may become less convenient to work with over time (because scaffolding tools don't understand your conventions) and the conventions are less familiar to people who are experienced with the framework. Both short-term and long-term project convenience is considered, but long-term convenience is preferred as it provide a more stable development cycle."}),(0,a.jsx)("p",{children:"The programming language should provide suitable abstractions that can be used to remove much of the semantic code duplication. Such languages usually give inspiration to libraries that cover some of the utility functionality that you would've had to write yourself otherwise, saving maintenance time and effort."}),(0,a.jsx)("h5",{children:"Lead Time for Change"}),(0,a.jsx)("p",{children:"The most important thing to improve this metric is to have fully automated regression tests. The time it takes to write regression tests more than make up for it in how fast and reliable they are execute compared to manual tests that has to be performed for every deployment."}),(0,a.jsx)("p",{children:"End-to-end tests are a must, but each test can take a long time to execute, and some scenarios are hard to replicate. A test pyramid should be used, with many more unit tests than end-to-end tests, with integration tests being somewhere in the middle. A tech stack should allow for unit and integration tests, and be flexible enough that you can test on many different levels of the pyramid based on the needs of the product."}),(0,a.jsx)("h5",{children:"Mean-Time to Recovery"}),(0,a.jsx)("p",{children:"The tech stack should allow for detection of problems quickly and allow you to rollback a deployment."}),(0,a.jsx)("h5",{children:"Change-Failure Rate"}),(0,a.jsx)("p",{children:"It should be hard to introduce a regression, which should've been caught by the tests. It's important that business requirements can be easily translated to tests with minimum risk conversion errors."}),(0,a.jsx)("h4",{children:"Familiarity vs Freedom"}),(0,a.jsx)("p",{children:"Certain tech stacks have very strong conventions and language limitations."}),(0,a.jsx)("p",{children:"This is useful when it comes to hiring, since it gives rise to more shared knowledge that doesn't have to be learned by people that are already familiar with the tech stack. It also makes it hard for rogue employees to write complex code that becomes more difficult to maintain once that person leaves the organization."}),(0,a.jsx)("p",{children:"The degree of familiarity vs freedom in a tech stack can often be traced back to the programming language culture. The culture influences what libraries gets written, how big they become, the granularity of the options they offer, how many alternatives gets written, and how much competition there is among the alternatives."}),(0,a.jsx)("p",{children:"I appreciate familiarity over freedom for the most part. A product should have the ability to grow and be refactored over time, which requires a degree of freedom. It's also important that familiarity doesn't gives rise to semantic duplication just to keep the amount of language features down."}),(0,a.jsx)("h4",{children:"Ecosystem"}),(0,a.jsx)("p",{children:"In order to develop an application, you probably want more than just a compiler."}),(0,a.jsx)("p",{children:"You want a good debugger, build tools and libraries, with good documentation, how-to guides and tutorials. You want to be able to find information about these things quickly and not get side-tracked by outdated and irrelevant information."}),(0,a.jsx)("p",{children:"A young tech stack with a lot of hype behind it will not have a problem with outdated information, since there isn't a lot of old information to begin with. At the same time, most things in this kind of ecosystem is unstable, and may change frequently or significantly. It can take time and effort to keep up with the pace while dodging bugs that are bound to be introduced when there are a lot of changes in the tools and libraries."}),(0,a.jsx)("p",{children:"As a tech stack gets older, it will hopefully keep some of the hype up. Otherwise, it can be hard to convince new programmers to use the stack. Some modern, useful ideas might not be integrated into the language, at least not at a fast pace."}),(0,a.jsx)("p",{children:"No tech stack will keep its' hype once it becomes mature, but I feel like these stacks are the most trustworthy to bet on if they keep some of the hype."}),(0,a.jsx)("h4",{children:"Development Environment"}),(0,a.jsx)("p",{children:"It's a plus if a tech stack works on the 3 major operating systems: Windows, OS X and Linux."}),(0,a.jsx)("p",{children:"It's a must that it works on Linux at least, in case Linux containers will be used to deploy the application, which has become increasingly common. Linux servers are also cheaper to build/rent, easier to modify, and more customizable than Windows servers."}),(0,a.jsx)("h3",{children:"Kinds of applications"}),(0,a.jsx)("h4",{children:"Static Website"}),(0,a.jsx)("p",{children:'This is a website that doesn\'t serve dynamic content -  i.e. no "backend" is needed.'}),(0,a.jsx)("p",{children:"Easier to reason about, good for blogs, and cheap to host."}),(0,a.jsx)("h4",{children:"Dynamic Website"}),(0,a.jsx)("p",{children:"A website that can serve dynamic content."}),(0,a.jsx)("p",{children:"May eventually become very large. It's important to refactor these websites over time so they can be divided into libraries, micro frontends and/or micro services if desirable."}),(0,a.jsx)("h4",{children:"Micro Service/Frontend"}),(0,a.jsx)("p",{children:"A part of a greater application that fulfills some domain-specific purpose."}),(0,a.jsx)("p",{children:"Micro services and frontends are usually not alone, or at least not for long. It's important to be able to quickly create new ones, and avoid duplicating api contract details between client and server."}),(0,a.jsx)("h3",{children:"Stacks"}),(0,a.jsx)("p",{children:"Below I will present my stack preferences for the kinds of applications presented in this article."}),(0,a.jsx)("h4",{children:"Static Website"}),(0,a.jsx)(TechStackEntry,{stack:m.static}),(0,a.jsx)("h4",{children:"Dynamic Website"}),(0,a.jsx)(TechStackEntry,{stack:m.dynamic}),(0,a.jsx)("h4",{children:"Micro Service/Frontend"}),(0,a.jsx)(TechStackEntry,{stack:m.microService}),(0,a.jsx)("h3",{children:"Reasoning"}),(0,a.jsx)("h4",{children:"Static Website"}),(0,a.jsx)("p",{children:"When it comes to building a simple website, there is almost no reason to use pure HTML/CSS/JS."}),(0,a.jsx)("p",{children:"You're at least going to want to reduce the repetition of the common head and body layout, at which point you might as well generate the website. Using a dynamic webserver to serve static content just complicates things and makes hosting more expensive."}),(0,a.jsx)("p",{children:"Jekyll is among the better static site generators for how easy-to-use and extensible it is. It's also the static website generator of choice for GitHub Pages, which is a plus."}),(0,a.jsx)("h4",{children:"Dynamic Website"}),(0,a.jsx)("p",{children:"If you need to support user accounts and forms, then Jekyll will not be enough."}),(0,a.jsx)("p",{children:"Ruby on Rails was considered for the backend, but it felt more simple to use the same language on the frontend and the backend. Sails.js was considered for how similar it is to Ruby on Rails, but it has not seen that much activity and doesn't have a big community. Also, some of the things that was attractive about Ruby on Rails is not present, such as opinionated integration testing."}),(0,a.jsx)("p",{children:"React was chosen as the underlying rendering framework because it feels more stable in its' niche. Angular competes more directly with Vue since they both primarily use a templating language instead of JSX. In my experience, it has been easier to integrate tool support for JSX rather than support for Vue's special .vue files."}),(0,a.jsx)("p",{children:"Jest was chosen for testing because it's opinionated when it comes to mocking."}),(0,a.jsx)("p",{children:"Gatsby.js was chosen over Next.js and Nuxt.js partially for its' greater accessibility features. Blitz.js was considered since it's a fullstack framework that reduces friction between frontend and backend. However, it's a very young framework that I don't think is ready for production use."}),(0,a.jsx)("h4",{children:"Micro Service/Frontend"}),(0,a.jsx)("h5",{children:"Why not Node?"}),(0,a.jsx)("p",{children:"There are a number of reasons for jumping of the fullstack Javascript bandwagon."}),(0,a.jsx)("p",{children:"First, I think the JVM ecosystem is better for backend development than Node."}),(0,a.jsx)("p",{children:"Most libraries have higher cohesion with trusted groups of maintainers rather than single line libraries with individual maintainers."}),(0,a.jsx)("p",{children:"There is less friction in build tools: Maven and Gradle are the only serious options and they have commonly followed conventions."}),(0,a.jsx)("p",{children:"There is less friction in testing tools: JUnit dominates."}),(0,a.jsx)("p",{children:"It's easy to switch language without having to add separate plugins for bundling, execution and testing."}),(0,a.jsx)("p",{children:"The JVM ecosystem has stood the test of time, and shortcomings are being addressed at a fast rate. It will soon be hard to argue that Java is outdated."}),(0,a.jsx)("p",{children:"A website can start of with the Dynamic Website stack when small, and once it reaches a certain complexity it can be divided into micro services one at a time until the original website is just a shell that can easily be replaced."}),(0,a.jsx)("h5",{children:"Why everything else?"}),(0,a.jsx)("p",{children:"Java is absorbing useful features from other languages at an increasing rate. Java recently gained records and text blocks, and will eventually get value types and lightweight threads, making coroutines not as important in some scenarios. Given all this, why would you bet on Kotlin instead of Java?"}),(0,a.jsx)("p",{children:"Kotlin was chosen over Java because it's similar enough while providing enough development productivity gains to offset the potential rewrite to Java in the future. There are tools for converting between the two, tests prevent accidental regressions, and small libraries / micro services / micro fragments prevent the need for a big rewrite."}),(0,a.jsx)("p",{children:"Quarkus was chosen over Spring Boot for the same reason. Spring Boot is currently not as easy to Google since there is a lot of old guides that don't use current best practices, which Spring Framework keeps backwards-compatibility for. It's also the case that Spring Boot uses runtime Dependency Injection and can't be statically compiled through GraalVM yet. You don't always value startup time over long-term runtime performance, but when you do, it's nice to have the option. This might change in the future, but for now, Quarkus shows no sign of slowing down."}),(0,a.jsx)("p",{children:"Liquibase was chosen over Flyway because it has more features without requiring a lot more configuration."}),(0,a.jsx)("p",{children:"The reason I prefer JooQ over JDBI is that they both allow you to write SQL, but JooQ offers more options while reducing the amount of POJOs you'll have to write by hand. Hibernate was also rejected because the object-relational mismatch solution it tries to provide does not make up for the increase in complexity. With Hibernate, there is a risk that you get stuck debugging for hours trying to perform some conceptually simple data modeling problem, which can make certain increments inexplicably take a lot of time. The much more simple abstraction provided by JooQ does not present the same risk."}),(0,a.jsx)("p",{children:"Gradle was preferred over Maven because of the speed of development and the ability to solve complicated build setups that are hard with Maven. Gradle requires a lot of care so that it doesn't become too hard to maintain though."}),(0,a.jsx)("p",{children:"Typescript was chosen over Javascript because it makes it easier for humans and tools to understand the design of the code. It requires more setup which isn't always necessary for a small app. It remains to be seen if Kotlin for Javascript will be worth using in the future."}),(0,a.jsx)("h4",{children:"Database"}),(0,a.jsx)("p",{children:"Postgres was chosen for data storage for its' extensibility. It can store normalized relational data as well as documents effectively, while providing a very powerful query language. Its' ability to define custom data types reduces the relational-object mismatch somewhat. Having explicit schemas makes it easier to make assertions about what data inconsistencies cannot exist, reduces the chance of introducing them, and doesn't require complicated migration scripts for semantically simple schema changes, such as column renaming."}),(0,a.jsx)("p",{children:"Different databases might be preferred depending on the kind of data that it needs to store. ACID-compliant databases are great because they offer you the opportunity to start with transactions and then move towards more complicated application-controlled optimistic locking if required for performance reasons."}),(0,a.jsx)("p",{children:"Caching is completely different. It should be performed as close to the client as possible. Redis is a good choice in a lot of cases."}),(0,a.jsx)("h4",{children:"Version Control"}),(0,a.jsx)("p",{children:"I liked Mercurial quite a lot a few years ago, but it has been losing too much market share to Git at this point."}),(0,a.jsx)("p",{children:"GitHub was chosen over GitLab because of developer familiarity rather than technical excellence. They are about on par when it comes to desired features though."}),(0,a.jsx)("p",{children:"GitLab is probably preferred if you need self-hosting."}),(0,a.jsx)("h4",{children:"Hosting"}),(0,a.jsx)("p",{children:"If you need anything beyond static website hosting, then I prefer Azure over AWS and GCS. AWS felt very unintuitive to use. GCS feels risky to rely on, given their track-record with abandoning services."}),(0,a.jsx)("p",{children:"Heroku gives off the impression that you might be stuck due to lack of flexibility in their offerings."}),(0,a.jsx)("p",{children:"Digital Ocean doesn't offer SaaS hosting."}),(0,a.jsx)("h3",{children:"Summary"}),(0,a.jsx)("p",{children:"As websites get more complicated, my preferences steer from Ruby static site rendering, to fullstack Node to frontend Node+backend JVM. It's important to use the right tool for the right job, and have a migration plan if the requirements change in such a way that a new tool is preferred. Use tools that work well together to produce small iterations and the productivity will come to you."}),(0,a.jsx)("p",{children:"If Ruby on Rails did not peter out during the last 10 years, I might've included it in one of the stacks. Will Node and JVM still be useful and popular choices in the next 10 years? It remains to be seen which trends will continue, and what new trends will appear."})]})},metadata:{title:"Tech Stack",slug:"tech-stack",date:"2020-07-21"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("h3",{children:"In the beginning"}),(0,a.jsx)("p",{children:"When working at a certain company I've come to appreciate the importance of independent teams. When I started working in 2017 we effectively had a monolith codebase - the code division between the teams was not obvious and you commonly had to touch other team's code to get work done."}),(0,a.jsx)("p",{children:'We had an initial "micro service" architecture, but it suffered from the same problems. The division of services among teams was not one-to-one, and several services were shared by multiple teams. The services shared a database and a helper library. The services used in-memory caches that had to be held up-to-date.'}),(0,a.jsx)("p",{children:"In order to make any improvements bigger than a single endpoint you had to bring it up on a weekly meeting with other teams because it would indirectly affect them."}),(0,a.jsx)("p",{children:"You could not release your changes independently. Even if your changes were low risk, they had to be released with other teams' code in the same release, so every release was effectively high-risk. If there was a problem with one part of the deploy, all of it had to be rolled back."}),(0,a.jsx)("p",{children:"Brand-specific changes were developed by a single team. DBAs, QA, UX, UI and DEV-OPS were all different teams. There was a lot of cross-coordination to get a single feature released."}),(0,a.jsx)("p",{children:"There was no clear idea of when and for what reason it was appropriate to create a micro service. e.g. an incident occurred where an idea micro service was sketched out in a ticket, which then almost made it to production without the original author being informed. The micro service was scrapped in the end."}),(0,a.jsx)("h3",{children:"The vision"}),(0,a.jsx)("p",{children:"Six months later, a stronger architectural vision was perpetuated. Domain-driven development would be used when designing micro services. We held meetings where we discussed bounded contexts and what business capability each new micro service would provide. More importantly, each context would be owned by a single team."}),(0,a.jsx)("p",{children:"This made it much easier to develop features independently of other teams. At best, a single feature only required work by a single team. The micro services could now be improved and deployed independently of each other."}),(0,a.jsx)("p",{children:"Members of QA and DEV-OPS are now dedicated to different teams in addition to their normal duties. Each team now provides their own frontend. Technologies were introduced to enable teams to do more work that previously required help from DEV-OPS."}),(0,a.jsx)("h3",{children:"My situation"}),(0,a.jsx)("p",{children:"As a developer that leaned towards architecture, I got the opportunity to improve my team's architecture, and also part of the overall architecture."}),(0,a.jsx)("p",{children:"I introduced a new temporary structure in the monolith for writing, and organizing testable code and tests. My team had split into three, and I tried my best to convince them and other teams of the value of writing team-independent code. This did not always work, and we still held company-wide meetings where we discussed the temporary monolith structure."}),(0,a.jsx)("p",{children:"The work towards micro services was a more significant improvement. In the beginning we made some mistakes of how to divide work between the three teams. In the middle of 2018 I wrote a high-level design of our bounded contexts that has stood the test of time, aside from a few minor changes."}),(0,a.jsx)("h3",{children:"Lessons"}),(0,a.jsx)("p",{children:"Micro services introduced their own issues, but the increase in productivity was staggering. It might've been possible to use a monolith app that imported plugins instead of dividing the domain across micro services. This would however not provide independent failures, it would balloon the size of the app, and require that all plugins use the same versions of external libraries. In the end, I think it was the right choice for the company to walk this path."})]})},metadata:{title:"Independent Teams",slug:"independent-teams",date:"2020-09-13"}},{component:function(){return(0,a.jsxs)(n.Fragment,{children:[(0,a.jsx)("h3",{children:"Introduction"}),(0,a.jsx)("p",{children:"I've been thinking lately about how to not just use architectural tactics in a vacuum, but also when to apply them and in what context. Different companies have their own issues and some may be more important than others, but I feel like it's good to have a heuristic for what to prioritize. Otherwise, you might focus on architectural aspects that ultimately don't matter."}),(0,a.jsx)("h3",{children:"Focus on the mission"}),(0,a.jsx)("p",{children:"Programming is primarily a means to an end - it's a way to solve problems in the real world as efficiently as possible, usually for an organization. A lot of software is never truly done, so \"efficiently\" doesn't just mean the initial development cost, but the cost of adding features over time, fixing bugs, training new hires, and keeping knowledge within the organization."}),(0,a.jsx)("p",{children:"You should ask the people in charge why they fund the technology at all - what would happen if all the technology was removed and all the tech-related employees quit? Why would it happen? The answer may start very general, but if you drill down you may find that some aspects of the technology is more important than others. This is a good starting point for what to focus on, at least initially."}),(0,a.jsx)("h3",{children:"Set aside your ego"}),(0,a.jsx)("p",{children:"Coming up with architectural ideas can be very fun, but it's easy to get attached to them. Once you do that, you may feel that critique of the idea becomes personal to you. Your attachment may mean that you don't feel comfortable with others implementing your solution, and you therefor decide to leave others in the dark."}),(0,a.jsxs)("p",{children:["Your area of responsibility will probably outgrow how long you have ownership of it. Due to the ",(0,a.jsx)(s(),{href:"https://en.wikipedia.org/wiki/Bus_factor",children:"bus factor"}),", the knowledge of the architecture should be distributed among more people in the organization. You should talk with other architects to get insight from them, and accept the fact that you might be wrong sometimes."]}),(0,a.jsxs)("p",{children:["I'm opposed to the idea that architecture is fully separated from software development. In general, the people who know most about a problem, and are the most invested in it are the people affected by it. ",(0,a.jsx)(s(),{href:"https://martinfowler.com/articles/scaling-architecture-conversationally.html",children:"Scaling the Practice of Architecture, Conversationally"})," provides a model for how to distribute architectural responsibility to where it makes most sense."]}),(0,a.jsxs)("p",{children:["Being a good architect means letting go, focusing on the mission, and inspiring other to do as well. Google found out that what makes good teams depends less on the individual members of the teams, but their ",(0,a.jsx)(s(),{href:"https://rework.withgoogle.com/blog/five-keys-to-a-successful-google-team/",children:"shared culture."})]}),(0,a.jsx)("h3",{children:"Maintain stability"}),(0,a.jsx)("p",{children:"It can be tempting to focus on all the long-term improvements for the architecture, while forgetting that you are working on a real system, used by real people who are experiencing problems today."}),(0,a.jsx)("p",{children:"Focus on big wins when improving stability. If you have an issue in production that prevents users from performing essential operations, try to solve the immediate issue first. End users sometimes like features, but they always hate when existing features stop working. Target a base-line for stability - being able to detect when customers have issues and solving the most common issues quickly is essential. Long-term stability is achieved by relying on other architectural aspects."}),(0,a.jsx)("h3",{children:"Measure improvements"}),(0,a.jsx)("p",{children:'Improvement measurements can be considered both on it\'s own and the potential for improvements. In other words: "Do end-users like the technology?" and "How prepared is the organization to improve the technology?"'}),(0,a.jsx)("h4",{children:"Do end-users like the technology?"}),(0,a.jsx)("p",{children:"There are a number of ways to measure how much end-users like your technology. You can either measure it qualitatively with personal interviews, or more quantitatively with questions whose results can be aggregated."}),(0,a.jsxs)("p",{children:["Quantitative measurements may involve surveys, but you can also automatically gather metrics of how end-users use your products. You can test whether or not end-users like a given change by running an ",(0,a.jsx)(s(),{href:"https://en.wikipedia.org/wiki/A/B_testing",children:"A/B test"})," and measure how many users in control group A or B performed the desired action(s) as a result of the change. Having good monitoring is useful to discover design issues, but also to detect when critical bugs are introduced that prevent end-users from performing desired actions."]}),(0,a.jsx)("h4",{children:"How prepared is the organization to improve the technology?"}),(0,a.jsxs)("p",{children:["By monitoring the key metrics from the ",(0,a.jsx)(s(),{href:"https://www.oreilly.com/library/view/accelerate/9781457191435/",children:"Accelerate Book"})," and aiming to improve them, you become more result-driven. For reference, the key metrics are:"]}),(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Deployment Frequency"}),(0,a.jsx)("li",{children:"Lead Time for Changes"}),(0,a.jsx)("li",{children:"Mean Time to Recovery"}),(0,a.jsx)("li",{children:"Change Failure Rate"})]}),(0,a.jsx)("h3",{children:"Divide the technology"}),(0,a.jsxs)("p",{children:["In order for a given technology to scale, you need to be able to divide it and talk about the parts individually. I recommend dividing the technology into different ",(0,a.jsx)(s(),{href:"https://www.domainlanguage.com/",children:"organization domains"})," based on what the technology is used for and can be used for. Different parts are more important than others, and the architecture should be built so that unimportant parts don't negatively affect the import ones. Advertising to end-users e.g. may be an important part of the technology, but it may be meaningless if the end-users cannot or aren't convinced to register accounts."]}),(0,a.jsx)("h3",{children:"Putting it all together"}),(0,a.jsx)("p",{children:"Which of these aspect are more important to focus on that others?"}),(0,a.jsx)("p",{children:"I feel like short-term stability is the most important one to focus on, especially if the lack of stability can cause a lot of distrust in end-users that can be hard or impossible to regain."}),(0,a.jsx)("p",{children:"The second most important aspect is the reality that you may only be a footnote in the history of the technology you are working on. Trust in others and multiply your footprint by inspiring them to become better architects."}),(0,a.jsx)("p",{children:"Learn what is most important to the organization, and once you know what that is, make sure you are able to measure that it's not getting worse over time."}),(0,a.jsx)("p",{children:"Once you know what is the most important part of the technology, isolate it from other parts that are not as important, and allow them to grow independently of each other."})]})},metadata:{title:"How to be a good architect?",slug:"good-architect",date:"2022-03-10"}}]},6462:function(e){e.exports={titleImages:"BricknodeFinancialModule_titleImages__mIOEW"}},9437:function(e){e.exports={titleImages:"SmwHacking_titleImages__dyx5x"}},5302:function(e){e.exports={titleImages:"one-image-article_titleImages__Pk84x"}}}]);